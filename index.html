
        var validBounds = L.latLngBounds(L.latLng(-95, -270), L.latLng(95, 270));

        // Create a Leaflet map and set the initial view
        var map = L.map('leaflet-map', {
            maxBounds: validBounds,
            zoomControl: false // default zoom control is on the left top.
        }).setView([40, 0], 2);

        L.control.zoom({ position: 'bottomright' }).addTo(map);
        L.control.scale({ metric: true, imperial: false }).addTo(map);
        map.addControl(new L.Control.Fullscreen({ position: 'topright' }));

        // Define basemap layers with their respective properties
        new L.basemapsSwitcher([
            {
                layer: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
                    attribution: 'Tiles &copy; Esri'
                }).setOpacity(0.9).addTo(map),//DEFAULT MAP
                maxZoom: 17,
                bounds: validBounds,
                icon: 'terrain.jpeg',
                name: 'Terrain'
            },
            {
                layer: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).setOpacity(0.7),
                icon: 'topo.jpg',
                bounds: validBounds,
                name: 'OpenTopo'
            },

            {
                layer: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
                }).setOpacity(0.7),
                maxZoom: 21,
                icon: 'satellite.jpg',
                bounds: validBounds,
                name: 'Satellite'
            },
            {
                layer: L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors)'
                }),
                icon: 'osm.png',
                bounds: validBounds,
                name: 'OSM'
            },
        ], { position: 'bottomleft' }).addTo(map);




        // 1. Variable Declarations and Initial Settings
        // Variables and settings
        var markers = L.markerClusterGroup({
            spiderfyOnMaxZoom: !1,
            removeOutsideVisibleBounds: !0,
            showCoverageOnHover: !1,
            zoomToBoundsOnClick: !1
        });
        var isLoadingData = !1,
            rectanglesGroup = new L.LayerGroup(),
            drawnItems = new L.FeatureGroup(),
            fetchedData = null,
            drawnBounds = null;
        let toggleState = "species";
        var maxSpeciesCount = 0,
            maxRecordingsCount = 0,
            toggleControl = L.control({ position: "topright" });
        const BASE_API_URL = "https://xeno-canto.org/api/internal/region-results";



        // Overriding the default tooltip text for rectangle drawing
        L.drawLocal.draw.handlers.rectangle.tooltip.start = "Click and drag a reactangle on desired area";
        // Configuration for the drawing controls on the map
        var drawControl = new L.Control.Draw({
            draw: {
                polyline: false,
                polygon: false,
                circle: false,
                marker: false,
                circlemarker: false,
                rectangle: {
                    shapeOptions: {},
                }
            },
            edit: {
                featureGroup: drawnItems,
                edit: false,
                remove: false
            }
        });
        map.addControl(drawControl);



        // 2. Event Listeners and Handlers
        // Event listeners and controls initialization
        map.on(L.Draw.Event.CREATED, handleLayerCreation);
        map.on('zoomend', handleZoomEnd);
        map.on('boxzoomend', handleBoxZoomEnd);

        // Event handler for clicking on a marker cluster
        markers.on('clusterclick', function (event) {
            let childMarkers = event.layer.getAllChildMarkers();
            let titlesList = childMarkers.map(marker => marker.options.title || 'No Title').join('<br>');
            event.layer.bindPopup(titlesList).openPopup();
        });
        map.addLayer(drawnItems);



        // 3. Data Fetching and Loading
        // Update the legend to show a "Loading" state
        function updateLegendToLoading() {
            $(".info.legend").html("Loading...");
            isLoadingData = true;
        }

        // Construct the API URL based on provided bounds
        function constructApiUrl(bounds) {
            return `${BASE_API_URL}?yn=${bounds._northEast.lat}&xe=${bounds._northEast.lng}&ys=${bounds._southWest.lat}&xw=${bounds._southWest.lng}`;
        }

        // Handle creation of a new drawn layer on the map
        function handleLayerCreation(event) {
            var layer = event.layer;
            drawnBounds = layer.getBounds();
            drawnItems.addLayer(layer);

            updateLegendToLoading();
            fetchDataAndCreateGrid(constructApiUrl(layer.getBounds()));
            drawnItems.clearLayers();
        }

        // Handle the end of a zoom event
        function handleZoomEnd() {
            if (isLoadingData) {
                updateLegendToLoading();
            } else {
                if (fetchedData) {
                    processDataAndCreateGrid(fetchedData);
                }
                updateVisibilityBasedOnZoom(map.getZoom());
            }
        }

        // Handle the end of a box zoom event
        function handleBoxZoomEnd(e) {
            drawnBounds = e.boxZoomBounds;

            updateLegendToLoading();

            let layer = L.rectangle([drawnBounds.getSouthWest(), drawnBounds.getNorthEast()]);
            drawnItems.addLayer(layer);

            fetchDataAndCreateGrid(constructApiUrl(drawnBounds));
            drawnItems.clearLayers();
        }

        // Fetch the data from the provided URL and create a grid on the map
        function fetchDataAndCreateGrid(apiUrl) {
            fetch(apiUrl)
                .then(response => response.json())
                .then(data => {
                    isLoadingData = false;  // Reset the loading state
                    fetchedData = data;
                    processDataAndCreateGrid(data);
                    $(".info.legend").show();
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                    isLoadingData = false;  // Reset the loading state even if there's an error
                });
        }


        // 4. Grid Visualization and Processing
        // Create markers and calculate counts for the grid based on fetched data
        function createMarkersAndCalculateGridCounts(data, gridSize) {
            const gridCounts = {};
            let maxSpeciesCount = 0;
            let maxRecordingsCount = 0;

            data.markers.forEach(markerData => {
                const markerIcon = L.icon({
                    iconUrl: 'marker-icon.png',
                    iconSize: [15, 15],
                });
                const marker = L.marker([markerData.lat, markerData.lon], {
                    icon: markerIcon,
                    title: markerData.title
                });
                markers.addLayer(marker);

                const gridLat = Math.floor(markerData.lat / gridSize) * gridSize;
                const gridLng = Math.floor(markerData.lon / gridSize) * gridSize;
                const gridKey = `${gridLat},${gridLng}`;
                const species = markerData.title.split(":")[1]?.trim();

                if (!gridCounts[gridKey]) {
                    gridCounts[gridKey] = {
                        species: new Set(),
                        recordings: 0
                    };
                }
                if (species) {
                    gridCounts[gridKey].species.add(species);
                }
                gridCounts[gridKey].recordings++;
                maxRecordingsCount = Math.max(maxRecordingsCount, gridCounts[gridKey].recordings); // Track the maximum recording count
            });

            for (let gridKey in gridCounts) {
                if (toggleState === 'species') {
                    maxSpeciesCount = Math.max(maxSpeciesCount, gridCounts[gridKey].species.size);
                } else {
                    maxRecordingsCount = Math.max(maxRecordingsCount, gridCounts[gridKey].recordings);
                }
            }

            return { gridCounts, maxSpeciesCount, maxRecordingsCount };
        }

        // Generate rectangles for the grids based on fetched data
        function generateRectanglesForGrids(data, gridCounts, maxSpeciesCount, maxRecordingsCount, gridSize) {

            const currentZoom = map.getZoom();

            if (currentZoom <= 2 && drawnBounds) {
                rectanglesGroup.clearLayers();

                let totalSpecies = 0;
                let totalRecordings = 0;

                for (let key in gridCounts) {
                    totalSpecies += gridCounts[key].species.size;
                    totalRecordings += gridCounts[key].recordings;
                }

                const color = toggleState === 'species'
                    ? getColor(totalSpecies, maxSpeciesCount * Object.keys(gridCounts).length)
                    : getColor(totalRecordings, maxSpeciesCount * Object.keys(gridCounts).length);


                let rectangle = L.rectangle(
                    [drawnBounds.getSouthWest(), drawnBounds.getNorthEast()],
                    { color: color, weight: 1 }
                ).bindTooltip(`${data.markers.length} recordings from ${new Set(data.markers.map(m => m.title.split(":")[1]?.trim())).size} species`);
                rectanglesGroup.addLayer(rectangle);

                map.addLayer(rectanglesGroup);
                return;
            }


            for (let gridKey in gridCounts) {
                const [gridLat, gridLng] = gridKey.split(',').map(Number);
                const speciesCount = gridCounts[gridKey].species.size;
                const recordingsCount = gridCounts[gridKey].recordings;

                const color = toggleState === 'species'
                    ? getColor(speciesCount, maxSpeciesCount, 'species')
                    : getColor(recordingsCount, maxRecordingsCount, 'recordings'); // Use maxRecordingsCount for recordings

                const rectangle = L.rectangle(
                    [[gridLat, gridLng], [gridLat + gridSize, gridLng + gridSize]],
                    {
                        color: color,
                        weight: 1.2,
                        fillOpacity: 0.7
                    }
                );

                rectangle.bindTooltip(`${recordingsCount} recordings from ${speciesCount} species`);
                rectangle.on('mouseover', function (e) {
                    e.target.openTooltip();
                });
                rectangle.on('mouseout', function (e) {
                    e.target.closeTooltip();
                });

                rectanglesGroup.addLayer(rectangle);
            }
        }


        // Process fetched data to create the grid visualization on the map
        function processDataAndCreateGrid(data) {
            const zoomLevel = map.getZoom();
            const gridSize = getGridSizeForZoom(zoomLevel);

            markers.clearLayers();
            rectanglesGroup.clearLayers();

            const { gridCounts, maxSpeciesCount, maxRecordingsCount } = createMarkersAndCalculateGridCounts(data, gridSize);

            const maxCount = toggleState === 'species' ? maxSpeciesCount : maxRecordingsCount;
            $(".info.legend").html(getLegendContent(maxCount));

            generateRectanglesForGrids(data, gridCounts, maxSpeciesCount, maxRecordingsCount, gridSize);

            map.addLayer(rectanglesGroup);
            updateVisibilityBasedOnZoom(map.getZoom());
        }


        // Update the visibility of markers or rectangles based on zoom level
        function updateVisibilityBasedOnZoom(zoom) {
            const toggleButton = document.getElementById('toggle-btn');



            if (zoom > 11) {
                rectanglesGroup.removeFrom(map);
                map.addLayer(markers);
                if (drawnBounds) {
                    showLegend();
                    toggleButton.style.display = 'block';
                } else {
                    hideLegend();
                    toggleButton.style.display = 'none';
                }
            } else if (zoom >= 3) {
                map.removeLayer(markers);
                rectanglesGroup.addTo(map);
                if (drawnBounds) {
                    showLegend();
                    toggleButton.style.display = 'block';
                } else {
                    hideLegend();
                    toggleButton.style.display = 'none';
                }
            } else {
                map.removeLayer(markers);
                rectanglesGroup.addTo(map);
                hideLegend(); // This ensures that the legend is hidden at zoom levels 1-3.
                toggleButton.style.display = 'none';
            }
        }







        // 5. Utility Functions
        // Determine the grid size based on current zoom level
        function getGridSizeForZoom(zoom) {
            console.log(zoom);
            if (zoom <= 2 && drawnBounds) {
                const widthInDegrees = drawnBounds.getEast() - drawnBounds.getWest();
                return widthInDegrees;
            }
            if (zoom >= 9) return 0.2;
            if (zoom >= 3) return 0.5;
        }

        // Determine the color based on the ratio of current count to the max count
        function getColor(count, maxCount) {
            const fraction = count / maxCount;

            if (fraction <= 0.2) return '#74A9CF';       // Light lavender
            if (fraction <= 0.4) return '#2B8CBE';       // Sky blue
            if (fraction <= 0.6) return '#FED976';       // Medium blue
            if (fraction <= 0.8) return '#FB6A4A';       // Deep blue
            return '#E31A1C';                            //  red
        }


        // Function to show the legend
        function showLegend() {
            $(".info.legend").show();
        }

        // Function to hide the legend
        function hideLegend() {
            $(".info.legend").hide();
        }

        // Toggle between the display states (species or recordings)
        function toggleDisplayState() {
            if (toggleState === 'species') {
                toggleState = 'recordings';
                this.innerHTML = "Switch to Species";
            } else {
                toggleState = 'species';
                this.innerHTML = "Switch to Recordings";
            }

            if (fetchedData) {
                processDataAndCreateGrid(fetchedData);
            }
        }



        // 6. Controls and Legends
        // Toggle control button to switch between display states
        toggleControl.onAdd = function (e) {
            var t = L.DomUtil.create("div", "toggle-control");
            t.innerHTML = '<button id="toggle-btn" style="display: none;">Switch to Recordings</button>';

            // Move the event listener code inside this function, after the button is added to the DOM
            var toggleBtn = t.querySelector("#toggle-btn");
            toggleBtn.addEventListener("click", toggleDisplayState);

            toggleBtn.addEventListener("mousedown", function () {
                map.doubleClickZoom.disable();
            });

            toggleBtn.addEventListener("mouseup", function () {
                setTimeout(() => map.doubleClickZoom.enable(), 10);
            });

            return t;
        };
        toggleControl.addTo(map);


        toggleControl.addTo(map);
        document.getElementById('toggle-btn').addEventListener('click', toggleDisplayState);


        // Legend control on the map
        var legend = L.control({ position: 'topright' });
        legend.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'info legend');
            //div.innerHTML = getLegendContent(0);  // Initially assume maxCount as 0
            return div;
        };


        // Generate the legend content based on max count
        function getLegendContent(maxCount) {
            if (!maxCount || maxCount === 0) {
                return "Loading...";
            }
            const grades = [
                0,
                Math.round(0.2 * maxCount),
                Math.round(0.4 * maxCount),
                Math.round(0.6 * maxCount),
                Math.round(0.8 * maxCount)
            ];

            let labels = [];

            // Convert grid size in degrees to kilometers and calculate the area
            const gridSizeInDegrees = getGridSizeForZoom(map.getZoom());
            const gridSizeInKm = gridSizeInDegrees * 111;  // Roughly 111 km per degree of latitude
            const gridSizeAreaInKm2 = Math.pow(gridSizeInKm, 2);  // Square the distance to get the area

            // Add the title at the top of the legend
            labels.push('<strong>' + (toggleState === 'species'
                ? 'Number of species'
                : 'Number of recordings') + '</strong>');

            for (let i = 0; i < grades.length; i++) {
                if (i < grades.length - 1) {
                    labels.push(
                        `<i style="background:${getColor(grades[i] + 1, maxCount)}"></i> ${grades[i]
                        }${grades[i + 1] ? ' &ndash; ' + (grades[i + 1] - 1) : '+'}`
                    );
                } else {

                    labels.push(
                        `<i style="background:${getColor(grades[i] + 1, maxCount)}"></i> ${grades[i]
                        } - ${maxCount}`
                    );
                }
            }

            // Wrapping the grid size info in a div to adjust spacing
            labels.push(`<div class="grid-size-info">Grid size: ~${gridSizeInKm.toFixed(2)} km (~${gridSizeAreaInKm2.toFixed(2)} km²)</div>`);

            return labels.join('<br>');
        }
        legend.addTo(map);


        // Initial visibility update based on current zoom level
        updateVisibilityBasedOnZoom(map.getZoom());


